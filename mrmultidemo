#!/usr/bin/env python3

import sys
import os
from multiprocessing import Pool, JoinableQueue, Process, current_process
import itertools
import re
import time
from random import randint

###############################
###                         ###
###  Classes                ###
###                         ###
###############################


class Path:
  """
  I instantiate a Path object, which has a pathname,
  a filesize, and a SHA1 hash.
  Calculating the SHA1 hash is expensive, so Path instances
  are maintained by a pool of concurrent processes.
  """

  def __init__(self,pathname):
    self.pathname   = pathname
    self.sha1       = None
    self.sha1_stamp = None

  def getsize(self):
    self.size = os.path.getsize(self.pathname)

  def getmtime(self):
    self.mtime = os.path.getmtime(self.pathname)


  def __str__(self):
    return self.pathname

  def __repr__(self):
    return self.pathname



class FolderTupleGenerator(object):
  """
  I instantiate an Iterator, which performs lazy evaluation
  of the os.walk call on the concatenation of topfolders.
  My 'next' nethod returns a tuple (path,dirlist,filelist)
  for exactly one walked folder path.
  """
  def __init__(self,topfolders):
    self.topfolders = topfolders
    print("FolderTupleGenerator has topfolders %r" % (self.topfolders))
    self.iterator = itertools.chain.from_iterable([os.walk(d) for d in topfolders])

  def __iter__(self):
    return self

  def __next__(self):
    return self.next()

  def next(self):
    try:
      item = list(self.iterator.__next__())
    except StopIteration:
      # print("FolderTupleGenerator caught and re-raising StopIteration")
      raise StopIteration
    # print("FolderTupleGenerator.next -> %r" % (item))
    return item


class PathGenerator(object):
  """
  I instantiate an iterator, which performs lazy evaluation of
  the os.walk call.
  My 'next' method returns one full pathname from my current dtuple,
  until it is exhausted, in which case I call foldertuplegenerator.next()
  to obtain a new dtuple for the next folder in the os.walk.
  """
  def __init__(self,foldertuplegenerator):
    self.foldertuplegenerator = foldertuplegenerator
    self.dtuple = None

  def __iter__(self):
    return self

  def __next__(self):
    return self.next()

  def next(self):
    if self.dtuple is None or len(self.dtuple[2]) == 0:  # no paths left, get some more
      # print("PathGenerator out of dtuple.filelist, obtain another")
      try:
        self.dtuple = self.foldertuplegenerator.next()
      except StopIteration:
        raise StopIteration
    try: 
      filename = self.dtuple[2].pop()
      pathname = os.path.join(self.dtuple[0],filename)
    except:
      raise StopIteration
    # print("PathGenerator -> %r" % (pathname))
    return pathname


class ChunkedPayloadGenerator(object):
  """
  I instantiate an Iterator, which performs lazy evaluation and assembly of
  a 'payload', which is an enumerated (non-lazy) list of Paths.
  """

  def __init__(self,payloadgenerator,payloadmax):
    self.payloadgenerator  = payloadgenerator
    self.payloadmax        = payloadmax

  def __iter__(self):
    return self

  def __next__(self):
    return self.next()

  def next(self):
    payload = []
    for n in range(self.payloadmax):
      try:
        item = self.payloadgenerator.next()
        payload.append(Path(item))
        # print("ChunkedPayloadGenerator got %s, len(payload) is %s" % (item,len(payload)))
      except StopIteration:
        # print("ChunkedPayloadGenerator caught StopIteration, --> payload is %r" % (payload))
        break
    if len(payload) > 0:
      return payload
    else:
      raise StopIteration



class PathPayloadProcess(Process):
  """
  I instantate a subclass which performs concurrent
  application-specific actions on queued work-items.
  """

  def run(self):
    """
    I take a single item off the Queue, and process it.
    Repeat, until there are no items left on the Queue.
    Each item is a list of Paths.
    """
    print("%s: process_path_payload invoked" % (self.name))
    while True:
      worklist = q.get()
      if worklist is not None:
        print("%s: Processing worklist %r" % (self.name,worklist))
        for item in worklist:
          print("%s: Processing %r" % (self.name,item.pathname))
          time.sleep(randint(1,4))
      q.task_done()



  


  




if __name__ == '__main__':

  target_folders = ['/etc']

  # Construct an interator for file-finding in the target_folders,
  # returns a lazy list of pathnames.
  foldertuplegenerator = FolderTupleGenerator(target_folders)
  pathgenerator = PathGenerator(foldertuplegenerator)
  chunkedpayloadgenerator = ChunkedPayloadGenerator(pathgenerator,4)

  q = JoinableQueue()

  for workitem in chunkedpayloadgenerator:
    if workitem is not None:
      print("workitem is %r" % (workitem))
      q.put(workitem)

  print("q now has %d entries" % (q.qsize()))

  num_worker_processes = 5

  for i in range(num_worker_processes):
    p = PathPayloadProcess(name="P%d" % (i), daemon=True)
    p.start()

  q.join()       # block until all tasks are done


